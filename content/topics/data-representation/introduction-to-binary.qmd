---
date: 2025-09-15
draft: false
subtitle: What's a bit, and how is it implemented in a computer?
title: Introduction to Binary
---

# Introduction to binary 

Everyone "knows" that computers use "binary" to operate

But, as we saw last class, computers don't "know" anything ultimately, its CPU is just configured to react in particularly sophisticated ways when its switches (the lightbulbs for the "guy in the box") are turned **on** or **off**.

So what is binary anyway? And what does it have to do with computers?

In order to understand the **Binary** numeral system, we can compare it to something we already know: the **Decimal** numeral system.

In **decimal** , numbers are represented by combinations of **ten ** different symbols: (0, 1, 2, 3, 4, 5, 6, 7, 8, 9).

We call decimal a **base 10** numeral system.

> If we have more than "9" of something, another **digit** is needed (another power of ten):
>
>   - 9 + 1 = 10
>   - 99 + 1 = 100, etc.

How do we represent numbers in binary and how does it compare to binary?

In **binary** , there are only **two** symbols (0, 1). 

We call binary a **base 2** numeral system.

> If we have more than "1" of something, another **bit** (power) is needed:
>
>
> - 1 + 1 = 10 (in english: one plus one equals two)
> - 11 + 1 = 100 (in english: three plus one equals four)

It's counterintuitive at first! But there's nothing fundamentally different about binary than decimal -- we're just more used to using decimal instead. Since we're reusing the symbols 1 and 0 from the decimal system, there is a convention to use **subscript** to disambiguate between different numeral systems:

> - **1~2~ + 1~2~ = 10~2~** is the same as **1~10~ + 1~10~ = 2~10~** is the same as **one plus one equals two**
>
> - **11~2~ + 1~2~ = 100~2~** is the same as **3~10~ + 1~10~ = 4~10~** is the same as **three plus one equals four**

These subscripts are not always required, but can be very useful when the numeral systems are mixed in the same context.

::: {.callout-note}

Note: binary and decimal are not the only possible numeral systems. All that distinguishes numeral systems is the number of symbols you agree to use to represent numbers -- there are infinite possible numeral systems!

**Hexadecimal** is another useful numeral system (16 symbols, or **base 16**) which we will discuss later in the course.

:::

### Bits: BInary digiTs

So what does binary have to do with computers?

 A **Bit** (Binary Digit) is the basic unit of information representing one of two discrete states. It is the smallest unit of information within the computer. Bits have one of two values:

- *0 (off) or 1 (on)*
- *0 (False) or 1 (True)*

We often compare this to a light switch being either on of off...

![Comparison between a bit and an ON (1) OFF (0) switch](https://media1.tenor.com/m/RlK21NHtq5UAAAAd/turn-off-shut-off.gif "A sample title."){fig-alt="Sample alt text. To be replaced!"}

------------------------------------------------------------------------

### How are Bits physically implemented?  **ðŸ”‹ âžœ âš¡ / ðŸ“´**

There are various ways to design circuits that effectively differentiate between "on" and "off" states. One method involves using a **transistor**, which can either be switched on or off to represent binary information. Another approach uses a **capacitor**, where its state of being charged or discharged conveys the desired data. In **magnetic** disks (like HDDs), information is stored as bits based on the direction of the magnetic field, either north-south or south-north. Similarly, on **optical discs** (such as CD-ROMs), bits are represented by whether a bit on the surface is shiny or not shiny. Lastly, over **telephone lines** or through **radio**, binary data is transmitted using high or low-pitched tones to represent the bits. Each of these methods relies on a distinct physical characteristic to represent binary information reliably.

![Capacitors can be charged or uncharged in RAM](_assets/data-representation2.png){fig-alt=""}


![A transistor is ON or OFF in any chip of the computer such as the CPU and GPU Source: [Any PCB](https://www.anypcba.com/upfile/blogs/articles/841/transistor-symbols.webp)](https://www.anypcba.com/upfile/blogs/articles/841/transistor-symbols.webp){fig-alt=""}

### Bytes

A Byte is a collection of bits known as the unit of digital information. Historically, it was the number of bits required to encode a single character.

1 Byte = 8 bits


Abbreviation: **B**. E.g. **4B** of storage means **4 Bytes** means **32 bits**.

![Bit versus Byte.](_assets/data-representation3.jpg "A sample title."){fig-alt="Sample alt text. To be replaced!"}

## History of Bytes

A byte represents the number of bits used to encode a single **character** in a computer, making it the smallest **addressable** unit of memory in many computer architectures. Historically, the size of a byte was hardware-dependent, with no universal standard governing its size. However, in 1993, a standard was introduced that defined the size of a byte as 8 bits, a convention that is now widely adopted across modern computing systems. This standardization has helped ensure consistency in how data is stored and processed across different platforms and devices.



### SI Convention

| Unit Name  | Symbol | Multiplying Factor | Multiplying factor (in thousands) | Description in English |
| ---------- | ------ | ------------------ | --------------------------------- | ---------------------- |
| Byte       | B      | 1                  | 1                                 | *One byte*             |
| Kilo Byte  | kB     | 1000               | 1000                              | *One thousand bytes*   |
| Mega Byte  | MB     | 1000,000           | 1000^2                            | *One million byte*     |
| Giga Byte  | GB     | 1000,000,000       | 1000^3                            | *One billion byte*     |
| Tera Byte  | TB     | 1000,000,000,000   | 1000^4                            | *One trillion byte*    |
| Peta Byte  | PB     | 10^15              | 1000^5                            | *One quadrillion byte* |
| Exa Byte   | EB     | 10^18              | 1000^6                            | *One quintillion byte* |
| Zetta Byte | ZB     | 10^21              | 1000^7                            | *One sextillion byte*  |
| Yotta Byte | YB     | 10^24              | 1000^8                            | *One septillion byte*  |

*Source: [NIST](https://www.nist.gov/pml/owm/metric-si-prefixes)*



## IEC Convention

To make things confusing, Windows and some other operating system don't follow the SI convention. They use the symbols Kb, Mb, etc but not referring to the powers of 10 we have seen above. They count the bytes in powers of 2! If a manufacturer makes a hard drive following the SI conventions, wthe operating system will recognize it as less bytes than indicated. 

In this course, we will use the **SI conventions** for Kilobytes as in 1000 bytes and we will differentiate it from powers of 2 using the **IEC convention**. In the end of the 1990s, the IEC adopted new prefixes to differentiate powers of 10 capacities (as described above) and powers of 2 capacities. 

| Unit Name | Symbol | Multiplying Factor | Multiplying factor (in thousands) |
| --------- | ------ | ------------------ | --------------------------------- |
| Kibi Byte | Kib    | 1000               | 1024                              |
| Debi Byte | Mib    | 1000,000           | 1024^2                            |
| Gibi Byte | Gib    | 1000,000,000       | 1024^3                            |
| Tebi Byte | Tib    | 1000,000,000,000   | 1024^4                            |
| Pebi Byte | Pib    | 10^15              | 1024^5                            |
| gibi Byte | Eib    | 10^18              | 1024^6                            |
| Zebi Byte | *Zib*  | 10^21              | 1024^7                            |
| Yobi Byte | Yib    | 10^24              | 1024^8                            |

<https://en.wikipedia.org/wiki/Byte#Multiple-byte_units>



:::{.callout-note}

Johnny buys a 1Tb external SSD but once plugs it into his Windows machine, noticies there are only 931 Gb. Can you explain why?

:::

# Representing Numbers in Binary

### Converting Decimal to Binary 

To convert a decimal number to binary: 

1. Find the power of 2 value for each bit of the binary number, starting
   from 0.(e.g., the power of 2 value for the 5th bit of a binary number
   is: 2^5^=32, etc.)

2. Add all the powers of two **wherever there is a 1** in the bit of the
   binary number

3. The sum of the powers of two above is the value of the binary number in
   decimal!


| Binary Number                             |          1          |    1    |    0    |    0    |    1    |
| :---------------------------------------- | :-----------------: | :-----: | :-----: | :-----: | :-----: |
| Step 1: identify each bit                 |       4th bit       | 3rd bit | 2nd bit | 1st bit | 0th bit |
| Step 2: power of 2                        |        2^4^         |  2^3^   |  2^2^   |  2^1^   |  2^0^   |
| Step 3: include value in sum if it's a 1. |         16          |    8    |    0    |    0    |    1    |
| Step 4: Add all terms                     | 16 + 8 + 1 = **25** |         |         |         |         |

Therefore, **11001~2~=25~10~**.

### Converting Binary to Decimal

Converting binary to decimal is easy to memorize for small numbers. 

For example: 

| Binary    | Binary |
| --------- | ------ |
| 0000 0000 | 1      |
| 0000 0001 | 2      |
| 0000 0010 | 3      |
| 0000 0011 | 4      |
| 0000 0100 | 5      |
| 0000 0101 | 6      |
| 0000 0110 | 7      |
| 0000 0111 | 8      |
| 0001 0000 | 9      |

What about larger numbers? How can we approach this problem systematically, i.e., use a defined method to confidently get the correct answer every time?

| Binary  | Decimal |
| :--     |  :--    |
| 1001    |  9      |
| 1101101 | ?      |
| 1111111 | ?      |
| 100000011000001 | ? |

After this lecture, you will have the tools to confidently fill out the rest of this table yourself!

Well, how do we do it for decimals? A large number, like 2608, is in fact **the combination of multiples of powers of ten**. When we say these numbers in English, we naturally **decompose** the number into its component parts:

> 2608 is **two thousand + six hundred + eight.**

Or, in other words:

> 2608 = 2x1000 + 2x100 + 0x10 + 8x1
>
> 2608 = **2x10^3^ + 6x10^2^ + 0x10^1^ + 8x10^0^**

We can use this exact method, with one key difference, to decompose the value of binary numbers just like decimal numbers.

What key difference? In Binary, we use **powers of 2 instead of powers of 10**.



------------------------------------------------------------------------

### Converting Decimal Number to Binary

Going the other way (from Decimal to Binary) is a bit less natural -- we cannot "see" directly from the decimal representation of a number (like 2608, for instance), how many powers of two are needed to make the equivalent number in binary.

Instead, we'll learn an **algorithm** (a series of deterministic steps to solve an analytical problem)

**Convert Decimal to Binary by Repeated Division**

1. Divide the decimal number by 2 using long division.

2. Note down the **outcome** and **remainder** of the division on the side.

3. Repeat steps 1 and 2 on the outcome until the outcome becomes zero.

4. The binary number will be the series of the remainders, read from **bottom to top** .



Convert 25 to binary.

Long Division (divide the Outcome by 2 at every step): 
![](_assets/data-representation7.png)
------------------------------------------------------------------------

:::{.callout-note}

One way of understanding this algorithm is to apply it to the base 10: 

![](_assets/data-representation8.png)

The higher powers are read from bottom to top, because these have been divided repeatedly. 

:::

How many Numbers can I represent?
------------------------------------------------------------------------

-   1 bit -\> can represent 2 numbers
    -   (0)2 = (0)10
    -   (1)2 = (1)10
-   2 bits -\> can represent 4 numbers
    -   (00)2 = (0)10
    -   (01)2 = (1)10
    -   (10)2 = (2)10
    -   (11)2 = (3)10
    -   Values: 0 to 3 in decimal.

------------------------------------------------------------------------

### n Bits â¬„ How many Numbers

**Possible Test Question**

How many numbers can I represent in 4 bytes? What is the first and last
number?

-   **n bits **
-   **-\> Can represent 2** **n** \_\_ numbers \_\_
-   **-\> Values: from 0 to (2** **n** \_\_ -1)\_\_
-   1 Byte -\> 8 bit -\> 28 numbers (256)
-   **First Number ** 0000 00002 = 010
-   **Last Number** 1111 11112 = 28-1 = 25510
-   2 Byte -\> 16 bit -\> 216 numbers (65536)
-   **First Number ** 0000 0000 0000 00002 = 010 to
-   **Last Number** 1111 1111 1111 11112 = 216-1 = 6553510

# Exercises 

### Practise problems

Convert the following binary numbers to decimal using the method above.

- 1001
- 1101101
- 1000001
- 1111111
- 100000011000001

Check your answers (you can google search "1001 binary to decimal" or similar to get an answer)

### Converting Decimal to Binary

Convert the following into binary. **Show your work** .

10

64

128

146

107

300
