---
date: 2025-09-15
draft: false
subtitle: What's a bit, and how is it implemented in a computer?
title: Introduction to Binary
---

# Introduction to binary 

Everyone "knows" that computers use "binary" to operate

But, as we saw last class, computers don't "know" anything ultimately, its CPU is just configured to react in particularly sophisticated ways when its switches (the lightbulbs for the "guy in the box") are turned **on** or **off**.

So what is binary anyway? And what does it have to do with computers?

In order to understand the **Binary** numeral system, we can compare it to something we already know: the **Decimal** numeral system.

In **decimal** , numbers are represented by combinations of **ten ** different symbols: (0, 1, 2, 3, 4, 5, 6, 7, 8, 9).

We call decimal a **base 10** numeral system.

> If we have more than "9" of something, another **digit** is needed (another power of ten):
>
>   - 9 + 1 = 10
>   - 99 + 1 = 100, etc.

How do we represent numbers in binary and how does it compare to binary?

In **binary** , there are only **two** symbols (0, 1). 

We call binary a **base 2** numeral system.

> If we have more than "1" of something, another **bit** (power) is needed:
>
>
> - 1 + 1 = 10 (in english: one plus one equals two)
> - 11 + 1 = 100 (in english: three plus one equals four)

It's counterintuitive at first! But there's nothing fundamentally different about binary than decimal -- we're just more used to using decimal instead. Since we're reusing the symbols 1 and 0 from the decimal system, there is a convention to use **subscript** to disambiguate between different numeral systems:

> - **1~2~ + 1~2~ = 10~2~** is the same as **1~10~ + 1~10~ = 2~10~** is the same as **one plus one equals two**
>
> - **11~2~ + 1~2~ = 100~2~** is the same as **3~10~ + 1~10~ = 4~10~** is the same as **three plus one equals four**

These subscripts are not always required, but can be very useful when the numeral systems are mixed in the same context.

::: {.callout-note}

Note: binary and decimal are not the only possible numeral systems. All that distinguishes numeral systems is the number of symbols you agree to use to represent numbers -- there are infinite possible numeral systems!

**Hexadecimal** is another useful numeral system (16 symbols, or **base 16**) which we will discuss later in the course.

:::

# Bits: BInary digiTs ‚ñ™Ô∏è‚ñ´Ô∏è

So what does binary have to do with computers?

 A **Bit** (Binary Digit) is the basic unit of information representing one of two discrete states. It is the smallest unit of information within the computer. Bits have one of two values:

- *0 (off) or 1 (on)*
- *0 (False) or 1 (True)*

We often compare this to a light switch being either on of off...

![Comparison between a bit and an ON (1) OFF (0) switch](https://media1.tenor.com/m/RlK21NHtq5UAAAAd/turn-off-shut-off.gif "A sample title."){fig-alt="Sample alt text. To be replaced!"}

------------------------------------------------------------------------

## How are Bits physically implemented?

There are various ways to design circuits that effectively differentiate between "on" and "off" states. One method involves using a **transistor**, which can either be switched on or off to represent binary information. Another approach uses a **capacitor**, where its state of being charged or discharged conveys the desired data. In **magnetic** disks (like HDDs), information is stored as bits based on the direction of the magnetic field, either north-south or south-north. Similarly, on **optical discs** (such as CD-ROMs), bits are represented by whether a bit on the surface is shiny or not shiny. Lastly, over **telephone lines** or through **radio**, binary data is transmitted using high or low-pitched tones to represent the bits. Each of these methods relies on a distinct physical characteristic to represent binary information reliably.

![Capacitors can be charged or uncharged in RAM](_assets/data-representation2.png){fig-alt=""}


![A transistor is ON or OFF in any chip of the computer such as the CPU and GPU Source: [Any PCB](https://www.anypcba.com/upfile/blogs/articles/841/transistor-symbols.webp)](https://www.anypcba.com/upfile/blogs/articles/841/transistor-symbols.webp){fig-alt=""}

# Bytes üáß

A Byte is a collection of bits known as the unit of digital information. Historically, it was the number of bits required to encode a single character.

1 Byte = 8 bits


Abbreviation: **B**. E.g. **4B** of storage means **4 Bytes** means **32 bits**.

![Bit versus Byte.](_assets/data-representation3.jpg "A sample title."){fig-alt="Sample alt text. To be replaced!"}

## History of Bytes  üìñ

A byte represents the number of bits used to encode a single **character** in a computer, making it the smallest **addressable** unit of memory in many computer architectures. Historically, the size of a byte was hardware-dependent, with no universal standard governing its size. However, in 1993, a standard was introduced that defined the size of a byte as 8 bits, a convention that is now widely adopted across modern computing systems. This standardization has helped ensure consistency in how data is stored and processed across different platforms and devices.



## SI Convention üìú

| Unit Name  | Symbol | Multiplying Factor | Multiplying factor (in thousands) | Description in English |
| ---------- | ------ | ------------------ | --------------------------------- | ---------------------- |
| Byte       | B      | 1                  | 1                                 | *One byte*             |
| Kilo Byte  | kB     | 1000               | 1000                              | *One thousand bytes*   |
| Mega Byte  | MB     | 1000,000           | 1000^2                            | *One million byte*     |
| Giga Byte  | GB     | 1000,000,000       | 1000^3                            | *One billion byte*     |
| Tera Byte  | TB     | 1000,000,000,000   | 1000^4                            | *One trillion byte*    |
| Peta Byte  | PB     | 10^15              | 1000^5                            | *One quadrillion byte* |
| Exa Byte   | EB     | 10^18              | 1000^6                            | *One quintillion byte* |
| Zetta Byte | ZB     | 10^21              | 1000^7                            | *One sextillion byte*  |
| Yotta Byte | YB     | 10^24              | 1000^8                            | *One septillion byte*  |

*Source: [NIST](https://www.nist.gov/pml/owm/metric-si-prefixes)*



## IEC Convention üìú

To make things confusing, Windows and some other operating system don't follow the SI convention. They use the symbols Kb, Mb, etc but not referring to the powers of 10 we have seen above. They count the bytes in powers of 2! If a manufacturer makes a hard drive following the SI conventions, wthe operating system will recognize it as less bytes than indicated. 

In this course, we will use the **SI conventions** for Kilobytes as in 1000 bytes and we will differentiate it from powers of 2 using the **IEC convention**. In the end of the 1990s, the IEC adopted new prefixes to differentiate powers of 10 capacities (as described above) and powers of 2 capacities. 

| Unit Name | Symbol | Multiplying Factor | Multiplying factor (in thousands) |
| --------- | ------ | ------------------ | --------------------------------- |
| Kibi Byte | Kib    | 1000               | 1024                              |
| Debi Byte | Mib    | 1000,000           | 1024^2                            |
| Gibi Byte | Gib    | 1000,000,000       | 1024^3                            |
| Tebi Byte | Tib    | 1000,000,000,000   | 1024^4                            |
| Pebi Byte | Pib    | 10^15              | 1024^5                            |
| gibi Byte | Eib    | 10^18              | 1024^6                            |
| Zebi Byte | *Zib*  | 10^21              | 1024^7                            |
| Yobi Byte | Yib    | 10^24              | 1024^8                            |

<https://en.wikipedia.org/wiki/Byte#Multiple-byte_units>



:::{.callout-note}

Johnny buys a 1Tb external SSD but once plugs it into his Windows machine, noticies there are only 931 Gb. Can you explain why?

:::

# Binary to Decimal  üî¢

Similar to the decimal system, the binary system breaksdown a number in powers of 2 composing this number. 
::: {layout-ncol=2}
![Decomposing 735 in powers of 10 Source: [Cheever](https://cheever.domains.swarthmore.edu/Ref/BinaryMath/NumSys.html)](_assets/data-representation9.png)

![Decomposing 181 in powers of 2 Source: [Cheever](https://cheever.domains.swarthmore.edu/Ref/BinaryMath/NumSys.html)](_assets/data-representation10.png)
:::

The steps to convert a binary number to decimal is straightforward üìù: 

1. 4Ô∏è‚É£ Find the power of 2 value for each bit of the binary number, starting from 0.(e.g., the power of 2 value for the 5th bit of a binary numberis: 2^5^=32, etc.)

2. 1Ô∏è‚É£ Add all the powers of two **wherever there is a 1** in the bit of the binary number

3. ‚ûï Add those powers of two ‚Üí this is the decimal!


| Binary Number                             |          1          |    1    |    0    |    0    |    1    |
| :---------------------------------------- | :-----------------: | :-----: | :-----: | :-----: | :-----: |
| Step 1: identify each bit                 |       4th bit       | 3rd bit | 2nd bit | 1st bit | 0th bit |
| Step 2: power of 2                        |        2^4^         |  2^3^   |  2^2^   |  2^1^   |  2^0^   |
| Step 3: include value in sum if it's a 1. |         16          |    8    |    0    |    0    |    1    |
| Step 4: Add all terms                     | 16 + 8 + 1 = **25** |         |         |         |         |

Therefore, **11001~2~=25~10~**.

# Decimal to Binary 1Ô∏è‚É£0Ô∏è‚É£
Converting binary to decimal is easy to memorize for small numbers. 

For example here is the binary numbers from 0 to 9: 

| Binary    | Binary |
| --------- | ------ |
| 0000 0000 | 1      |
| 0000 0001 | 2      |
| 0000 0010 | 3      |
| 0000 0011 | 4      |
| 0000 0100 | 5      |
| 0000 0101 | 6      |
| 0000 0110 | 7      |
| 0000 0111 | 8      |
| 0001 0000 | 9      |

What about larger numbers? How can we approach this problem systematically, i.e., use a defined method to confidently get the correct answer every time?

| Binary  | Decimal |
| :--     |  :--    |
| 1001    |  9      |
| 1101101 | ?      |
| 1111111 | ?      |
| 100000011000001 | ? |

After this lecture, you will have the tools to confidently fill out the rest of this table yourself!

Well, how do we do it for decimals? A large number, like 735, is in fact **the combination of multiples of powers of ten**. When we say these numbers in English, we naturally **decompose** the number into its component parts:

![Decomposing 735 in powers of 10 Source: [Cheever](https://cheever.domains.swarthmore.edu/Ref/BinaryMath/NumSys.html)](_assets/data-representation9.png)


> 735 is **six hundred + thirty + five.**

Or, in other words:

> 735 = 7x100 + 3x10 + 5x1
>
> 735 = **7x10^2^ +30x10^1^ +5x10^0^**

We can use this exact method, with one key difference, to decompose the value of binary numbers just like decimal numbers.

What key difference? In Binary, we use **powers of 2 instead of powers of 10**.


We'll learn an **algorithm** to systematically decompose any decimal number into binary:

**Convert Decimal to Binary by Repeated Division**

1. ‚ûó Divide the decimal number by 2 using long division.

2. ‚úçÔ∏è Write down the **quotient** and **remainder** of the division on the side.

3. üîÅ Repeat steps 1 and 2 on the outcome.

4. ‚õî Stop when the quotient becomes 0.

4. üì• Read the remainders from bottom to top ‚Üí this is the binary number.



## Example Convert 25 to binary.

Long Division (divide the Outcome by 2 at every step): 
![](_assets/data-representation7.png)
------------------------------------------------------------------------

:::{.callout-note}

One way of understanding this algorithm is to apply it to the base 10: 

![](_assets/data-representation8.png)

The higher powers are read from bottom to top, because these have been divided repeatedly. 

:::

---
# Range of numbers based on number of bits ‚ÜîÔ∏è

When using a fixed number of bits, the total number of unique values we can represent is always limited by 2^ùëõ^, where ùëõ is the number of bits. This means that no matter how we arrange the bits, once all possible combinations are used, we cannot create any new unique numbers without adding more bits. For example, with 3 bits we can only represent 8 values (0‚Äì7 in decimal), and with 8 bits (1 byte) we are restricted to 256 values (0‚Äì255). This limitation is why larger data types like 2 bytes (16 bits) or 4 bytes (32 bits) are needed when working with bigger numbers.

-   1 bit -\> can represent 2 numbers
    -   (0)~2~ = (0)~10~
    -   (1)~2~ = (1)~10~
-   2 bits -\> can represent 4 numbers
    -   (00)~2~ = (0)~10~
    -   (01)~2~ = (1)~10~
    -   (10)~2~ = (2)~10~
    -   (11)~2~ = (3)~10~
    -   Values: 0 to 3 in decimal.

::: {.callout-note icon="false"}
# Question
How many numbers can I represent in 4 bytes? What is the first and last number?

-   **n bits ** ‚Üí 4
-   **Can represent 2^n^*** ‚Üí 16 
-   **-\> Values: from 0 to (2** **n** \_\_ -1)\_\
-   **First Number** 0000 = (0)~10~
-   **Last Number** 1111 11112 = 28-1 = 25510
-   2 Byte -\> 16 bit -\> 216 numbers (65536)
-   **First Number ** 0000 0000 0000 00002 = 010 to
-   **Last Number** 1111 1111 1111 11112 = 216-1 = 6553510

:::

# Exercises 

### Practise problems

Convert the following binary numbers to decimal using the method above.

- 1001
- 1101101
- 1000001
- 1111111
- 100000011000001

Check your answers (you can google search "1001 binary to decimal" or similar to get an answer)

### Converting Decimal to Binary

Convert the following into binary. **Show your work** .

10

64

128

146

107

300
