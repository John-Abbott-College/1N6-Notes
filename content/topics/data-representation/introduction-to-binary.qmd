---
date: 2025-09-15
draft: true
subtitle: Lecture subtitle.
title: Introduction to Binary
---

# Introduction

Everyone "knows" that computers use "binary" to operate

But, as we saw last class, computers don't "know" anything --
ultimately, its CPU is just configured to react in particularly
sophisticated ways when its switches (the lightbulbs for the "guy in the box") are turned **on**
or **off**.

So what is binary anyway? And what does it have to do with computers?

In order to understand the **Binary** numeral system, we can compare it
to something we already know: the **Decimal** numeral system.

## Lesson Overview

- Numeric Systems: Binary vs. Decimal
- Representing Numbers in Binary
- Representing Text in Binary

## Lesson Content

# What is Binary?

## Parallel with Decimal Numbers

In **decimal** , numbers are represented by combinations of **ten ** different symbols: (0, 1, 2, 3, 4, 5, 6, 7, 8, 9).

We call decimal a **base 10** numeral system.

> If we have more than "9" of something, another **digit** is needed (another power of ten):
>
>   - 9 + 1 = 10
>   - 99 + 1 = 100, etc.

How do we represent numbers in binary?

## Binary Numbers

In **binary** , there are only **two** symbols (0, 1). 

We call binary a **base 2** numeral system.

> If we have more than "1" of something, another **bit** is needed:
>
>
> - 1 + 1 = 10 (in english: one plus one equals two)
> - 11 + 1 = 100 (in english: three plus one equals four)

It's counterintuitive at first! But there's nothing fundamentally different about binary than decimal -- we're just more used to using decimal instead.

------------------------------------------------------------------------

Since we're reusing the symbols 1 and 0 from the decimal system, there is a convention to use **subscript** to disambiguate between different numeral systems:

> - **1~2~ + 1~2~ = 10~2~** is the same as **1~10~ + 1~10~ = 2~10~** is the same as **one plus one equals two**
>
> - **11~2~ + 1~2~ = 100~2~** is the same as **3~10~ + 1~10~ = 4~10~** is the same as **three plus one equals four**

These subscripts are not always required, but can be very useful when the numeral systems are mixed in the same context.

Note: binary and decimal are not the only possible numeral systems. All that distinguishes numeral systems is the number of symbols you agree to use to represent numbers -- there are infinite possible numeral systems!

**Hexadecimal** is another useful numeral system (16 symbols, or **base 16**) which we will discuss later

### Bits: BInary digiTs

So what does binary have to do with computers?

- **Bit** (Binary Digit) is the basic unit of information representing one of two discrete states. It is the smallest unit of information within the computer.
- Bits have one of two values:
  - *0 (off) or 1 (on)*
  - *0 (False) or 1 (True)*



![Comparison between a bit and an ON (1) OFF (0) switch](https://media1.tenor.com/m/RlK21NHtq5UAAAAd/turn-off-shut-off.gif "A sample title."){fig-alt="Sample alt text. To be replaced!"}

------------------------------------------------------------------------

### How are Bits Represented in a Computer?

There are many ways we can design circuits that reliably tell the difference between on/off:

- A **transistor** that is switched on or off.
- A **capacitor** that is charged or discharged.
- On magnetic disks (HDD): bits are represented by direction of the magnetic field (N-S, S-N).
- On optical discs (CD-ROM): bits are represented optically (a bit on the surface is either shiny or not shiny).
- Over telephone lines/radio: bits represented using high/low-pitched tones.

![](_assets/data-representation2.png){fig-alt=""}


![](_assets/data-representation6.png){fig-alt=""}

### Bytes

A Byte is a collection of bits known as the unit of digital information. Historically, it was the number of bits required to encode a single character.

1 Byte = 8 bits


Abbreviation: **B**. E.g. **4B** of storage means **4 Bytes** means **32 bits**.

![Bit versus Byte.](_assets/data-representation3.jpg "A sample title."){fig-alt="Sample alt text. To be replaced!"}

### History

-   The byte represents the number of bits used to encode one **character** in a computer and hence it is the smallest __addressable__ unit of memory in several computer architectures.
-   Size of a byte has been hardware dependent and no definitive standards existed that mandated the size.
-   A standard was introduced in 1993 that is common now.
-   1 byte = 8 bits

------------------------------------------------------------------------

### Scale: SI Prefixes

-   1 byte ( **B** )
-   **Kilo** byte (KB) = 1,000 bytes
    -   "one *thousand* bytes"
-   **Mega** byte (MB) = 1,000,000 bytes
    -   "one *million* bytes"
-   **Giga** byte (GB) = 1,000,000,000 bytes
    -   "one *billion* bytes"
-   **Tera** byte (TB) = 1,000,000,000,000
    -   "one *trillion* bytes"

<https://www.nist.gov/pml/owm/metric-si-prefixes>

------------------------------------------------------------------------

#### Non SI-Prefixes: Powers of 2

-   1 byte ( **B** )
-   **Kibi** byte (KiB) = 1,024 bytes (210) = 1.024KB
-   1,024 = 2 \* 2 \* 2 \* 2 \* 2 \* 2 \* 2 \* 2 \* 2 \* 2
-   **Mebi** byte (MiB) = 1,048,576 bytes (220) = 1.048 MB
-   **Gibi** byte (GiB) = 1,073,741,824 bytes (230) = 1.073 GB
-   **Tebi** byte (TiB) = 1,099,511,627,776 bytes (240) = 1.1 TB

<https://en.wikipedia.org/wiki/Byte#Multiple-byte_units>

![Note: the difference between SI and Non-SI systems start small, but grow
in significance at larger sizes of storage. See
*<https://superuser.com/a/433216>* for a thorough explanation](_assets/data-representation4.png "A sample title."){fig-alt="Sample alt text. To be replaced!"}

# Representing Numbers in Binary

### Converting Binary to Decimal

Converting binary to decimal is easy to memorize for small numbers. For
example:

 Binary   Decimal
-------- ---------
   0         0
   1         1
   10        2
   11        3
  100        4
  101        5
  110        6

------------------------------------------------------------------------

What about larger numbers? How can we approach this problem systematically, i.e., use a defined method to confidently get the correct answer every time?

| Binary  | Decimal |
| :-:     |  :-:    |
| 1001    |  9      |
| 1101101 | ?      |
| 1111111 | ?      |
| 100000011000001 | ? |

After this lecture, you will have the tools to confidently fill out the rest of this table yourself!

------------------------------------------------------------------------

Well, how do we do it for decimals? A large number, like 2608, is in fact **the combination of multiples of powers of ten**. When we say
these numbers in English, we naturally **decompose** the number into its component parts:

> 2608 is **two thousand, six hundred, and eight.**

Or, in other words:

> 2608 = 2x1000 + 2x100 + 0x10 + 8x1
>
> 2608 = **2x10^3^ + 6x10^2^ + 0x10^1^ + 8x10^0^**

We can use this exact method, with one key difference, to decompose the value of binary numbers just like decimal numbers.

What key difference? In Binary, we use **powers of 2 instead of powers of 10**.

------------------------------------------------------------------------
::: {.callout-note}
# Example

To convert a decimal number to binary: 

1. Find the power of 2 value for each bit of the binary number, starting
from 0.(e.g., the power of 2 value for the 5th bit of a binary number
is: 2^5^=32, etc.)

2. Add all the powers of two **wherever there is a 1** in the bit of the
binary number

3. The sum of the powers of two above is the value of the binary number in
decimal!


| Binary Number | 1 | 1 | 0 | 0 | 1 |
| :----- | :-: | :-: | :-: | :-: | :-: |
| Step 1: identify each bit | 4th bit | 3rd bit | 2nd bit | 1st bit | 0th bit |
| Step 2: power of 2 | 2^4^ | 2^3^  | 2^2^ | 2^1^ | 2^0^ |
| Step 3: include value in sum if it's a 1. | 16 | 8 | 0 | 0 | 1 |
| Step 4: Add all terms | 16 + 8 + 1 = **25** |||||

Therefore, **11001~2~=25~10~**.
:::


#### Practise problems

Convert the following binary numbers to decimal using the method above.

- 1001
- 1101101
- 1000001
- 1111111
- 100000011000001

Check your answers (you can google search "1001 binary to decimal" or similar to get an answer)

------------------------------------------------------------------------

### Converting Decimal Number to Binary

Going the other way (from Decimal to Binary) is a bit less natural -- we cannot "see" directly from the decimal representation of a number (like 2608, for instance), how many powers of two are needed to make the equivalent number in binary.

Instead, we'll learn an **algorithm** (a series of deterministic steps to solve an analytical problem)

**Convert Decimal to Binary by Repeated Division**

1. Divide the decimal number by 2 using long division.

2. Note down the **outcome** and **remainder** of the division on the side.

3. Repeat steps 1 and 2 on the outcome until the outcome becomes zero.

4. The binary number will be the series of the remainders, read from **bottom to top** .

------------------------------------------------------------------------

Convert 25 to binary.

Long Division (divide the Outcome by 2 at every step): 
![](_assets/data-representation7.png)
------------------------------------------------------------------------


### How many Numbers can I represent?

-   1 bit -\> can represent 2 numbers
    -   (0)2 = (0)10
    -   (1)2 = (1)10
-   2 bits -\> can represent 4 numbers
    -   (00)2 = (0)10
    -   (01)2 = (1)10
    -   (10)2 = (2)10
    -   (11)2 = (3)10
    -   Values: 0 to 3 in decimal.

------------------------------------------------------------------------

### n Bits ⬄ How many Numbers

**Possible Test Question**

How many numbers can I represent in 4 bytes? What is the first and last
number?

-   **n bits **
-   **-\> Can represent 2** **n** \_\_ numbers \_\_
-   **-\> Values: from 0 to (2** **n** \_\_ -1)\_\_
-   1 Byte -\> 8 bit -\> 28 numbers (256)
-   **First Number ** 0000 00002 = 010
-   **Last Number** 1111 11112 = 28-1 = 25510
-   2 Byte -\> 16 bit -\> 216 numbers (65536)
-   **First Number ** 0000 0000 0000 00002 = 010 to
-   **Last Number** 1111 1111 1111 11112 = 216-1 = 6553510

### 

------------------------------------------------------------------------

# Text in Computers

In early years, different computer companies applied the binary system
in their own way.

The word "cat" would be encoded in binary different on different brands
of computers.

This made life difficult in terms of being able to transfer data from
one system to another.

------------------------------------------------------------------------

### ASCII

-   ASCII (American Standard Code for Information Interchange)
    -   Standard introduced that used a 7 bit code with 128
        combinations.
-   Later became 8-bits (256 combinations) -- **extended ** ASCII-8.
    -   Note: When people say "ASCII" they are almost always referring
        to extended ASCII-8
-   Why eight bits?
    -   So each character can be stored in a single byte.
-   CAT 0100 0011 0100 0001 0101 0100
-   cat 0110 0011 0110 0001 0111 0100

### ASCII-8: Table of Characters

![](https://media.geeksforgeeks.org/wp-content/uploads/20240304094301/ASCII-Table.png)

*Information above comes from* [ASCII Values Alphabets](https://www.geeksforgeeks.org/dsa/ascii-table/)

------------------------------------------------------------------------

### Unicode

Although ASCII works fine for English and other Latin-based languages, many other languages need far more than 256 characters. For example, Chinese (汉字), Japanese (漢字), Cyrillic (Кири́ллица), Gujarati (ગુજરાતી), and Urdu (اردو) all require large sets of characters that ASCII simply cannot represent. With only 8 bits, ASCII cannot possibly store the hundreds of thousands of symbols used worldwide. To solve this, we use **Unicode**, which comes in several versions that use different numbers of bits to store data. The most common format is **UTF-8**, an 8-bit variable-width encoding that maximizes compatibility with ASCII while allowing expansion up to 48 bits for larger character sets. **UTF-16** uses 16-bit variable-width encoding and can expand to 32 bits, while **UTF-32** uses a fixed-width 32-bit system where every character takes exactly 32 bits. With over 60,000 characters supported in UTF-16 and more than 4 billion in UTF-32, Unicode can represent virtually every character from every language on the planet. For instance, the code point U+007A represents the Latin small letter *z* (007A in UTF-16), while U+6C34 represents the Chinese character for water (水), stored as 6C34 in UTF-16. Since the numbers used in UTF-16 and UTF-32 can be extremely large, it is not convenient to write them in binary, which is why we often use **hexadecimal** instead.  

*Information adapted from [Wikibooks: ASCII and Unicode](https://en.wikibooks.org/wiki/A-level_Computing/AQA/Paper_2/Fundamentals_of_data_representation/ASCII_and_unicode) — you can find more detailed explanations there.*

### Hexadecimal Numbers

------------------------------------------------------------------------

As we saw with **Unicode**, computers need to handle very large numbers in order to distinguish between the many possible characters and instructions. While computers have no problem working with large **binary numbers**, __we do!__ Converting 32-bit or 64-bit values from binary to decimal is tedious, which makes __large binary numbers hard for humans to read and write quickly__. We are comfortable using large **decimal numbers**, but the problem is that **10 is not a power of 2**, so it does not align evenly with the binary storage model that computers use. For example, with 4 bits we can represent values up to 16, but to store just a little more, like 17–20, we already need 5 bits. The consequence is that decimal numbers cannot be directly stored in machines built from transistors that can only distinguish between "on" and "off." So what do we do? We turn to **hexadecimal**, a system that maps neatly onto binary while remaining compact and much easier for humans to read and write. 

------------------------------------------------------------------------

-   Introduce a new numeric system! There are infinite possibilities...
-   **Hexadecimal numbers** are **base 16** .
-   Note: 16 is a power of 2! 2\^4 = 16
-   In other words:
-   with 4 bits, we can store one "hexit", values range from 0-1111 (0 -\> 15 in decimal)
-   with 8 bits, we can store exactly two "hexits", values range from 0 - 1111 1111 (0 -\> 255 in decimal)

------------------------------------------------------------------------

### Building Hexadecimal Numbers



> **Riddle**
>
> Avatar Aang went to get his first driving license. The clerk asked Aang
> for his ID to make sure he was old enough to do the driving test. The
> clerk read his ID, and told him that he is not old enough for the test.
> They him that he needs to be at least 18.
>
> Aang answered, "I'm sorry but you are wrong. I am exactly 18, in
> decimal. My ID in fact shows my age in Hexadecimal."
>
> What age is Aang in Hexadecimal(if he is indeed 18 in decimal?)
>
> ![Aang.](_assets/data-representation5.png "A sample title."){fig-alt="Sample alt text. To be replaced!"}



------------------------------------------------------------------------

### Why Hexadecimal?

Hexadecimal is perfect for matching 4 bits.

Every combination of 4 bits can be matched with one hex number.

*4 bits* can be represented by *1 Hex value ("hexit")*

*8 bits* can be represented by *2 Hex values ("hexit")*

------------------------------------------------------------------------

### Hexadecimal Digits

### Converting Decimal to Binary

Convert the following into binary. **Show your work** .

10

64

128

146

107

300
## Exercises

**Binary conversion**



**Ascii characters**

1. Decode the following message (left to right, top to
   bottom)

```text
0100 0001 0101 0011 0100 0011

0100 1001 0100 1001 0010 0000

0110 1001 0111 0011 0010 0000

0110 1100 0110 1001 0110 1101

0110 1001 0111 0100 0110 0101

0110 0100
```

